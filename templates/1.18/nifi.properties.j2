# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Core Properties #
nifi.version={{ nifi_version }}
nifi.flow.configuration.file={{ nifi_etc_dir }}/flow.xml.gz
nifi.flow.configuration.json.file={{ nifi_etc_dir }}/flow.json.gz
nifi.flow.configuration.archive.enabled=true
nifi.flow.configuration.archive.dir={{ nifi_etc_dir }}/archive/
nifi.flow.configuration.archive.max.time=30 days
nifi.flow.configuration.archive.max.storage=500 MB
nifi.flow.configuration.archive.max.count=
nifi.flowcontroller.autoResumeState=true
nifi.flowcontroller.graceful.shutdown.period={{ nifi_graceful_shutdown_secs }} secs
nifi.flowservice.writedelay.interval=500 ms
nifi.administrative.yield.duration=30 sec
# If a component has no work to do (is "bored"), how long should we wait before checking again for work?
nifi.bored.yield.duration=5 millis
nifi.queue.backpressure.count=10000
nifi.queue.backpressure.size=1 GB

nifi.authorizer.configuration.file={{ nifi_conf_dir }}/authorizers.xml
nifi.login.identity.provider.configuration.file={{ nifi_conf_dir }}/login-identity-providers.xml
nifi.templates.directory={{ nifi_etc_dir }}/templates
nifi.ui.banner.text=
nifi.ui.autorefresh.interval=30 sec
nifi.nar.library.directory={{ nifi_nar_dir }}
{% for custom_nar in nifi_custom_nars -%}
nifi.nar.library.directory.lib{{ loop.index }}={{ custom_nar }}
{% endfor -%}
nifi.nar.library.autoload.directory={{ nifi_nar_library_autoload_directory }}
nifi.nar.working.directory={{ nifi_work_dir }}/nar/
nifi.documentation.working.directory={{ nifi_work_dir }}/docs/components

####################
# State Management #
####################
nifi.state.management.configuration.file={{ nifi_conf_dir }}/state-management.xml
# The ID of the local state provider
nifi.state.management.provider.local=local-provider
# The ID of the cluster-wide state provider. This will be ignored if NiFi is not clustered but must be populated if running in a cluster.
nifi.state.management.provider.cluster=zk-provider
# Specifies whether or not this instance of NiFi should run an embedded ZooKeeper server
{% set is_zk_node = nifi_zookeeper_servers | intersect([hostvars[inventory_hostname]['ansible_default_ipv4']['address']]) | length > 0 -%}
{% set should_run_zk = nifi_state_management_embedded_zookeeper_start -%}
nifi.state.management.embedded.zookeeper.start={{ (is_zk_node and should_run_zk) | lower }}
# Properties file that provides the ZooKeeper properties to use if <nifi.state.management.embedded.zookeeper.start> is set to true
nifi.state.management.embedded.zookeeper.properties={{ nifi_conf_dir }}/zookeeper.properties

# H2 Settings
nifi.database.directory={{ nifi_database_repository }}
nifi.h2.url.append=;LOCK_TIMEOUT=25000;WRITE_DELAY=0;AUTO_SERVER=FALSE

# Repository Encryption properties override individual repository implementation properties
nifi.repository.encryption.protocol.version=
nifi.repository.encryption.key.id=
nifi.repository.encryption.key.provider=
nifi.repository.encryption.key.provider.keystore.location=
nifi.repository.encryption.key.provider.keystore.password=

# FlowFile Repository
nifi.flowfile.repository.implementation=org.apache.nifi.controller.repository.WriteAheadFlowFileRepository
nifi.flowfile.repository.wal.implementation=org.apache.nifi.wali.SequentialAccessWriteAheadLog
nifi.flowfile.repository.directory={{ nifi_flowfile_repository }}
nifi.flowfile.repository.checkpoint.interval=20 secs
nifi.flowfile.repository.always.sync=false
nifi.flowfile.repository.retain.orphaned.flowfiles=true

nifi.swap.manager.implementation=org.apache.nifi.controller.FileSystemSwapManager
nifi.queue.swap.threshold={{ nifi_queue_swap_threshold }}

# Content Repository
nifi.content.repository.implementation=org.apache.nifi.controller.repository.FileSystemRepository
nifi.content.claim.max.appendable.size={{ nifi_content_claim_max_appendable_size }}
{% for repo in nifi_content_repositories -%}
nifi.content.repository.directory.repo{{ loop.index0 }}={{ repo }}
{% endfor -%}
nifi.content.repository.archive.max.retention.period={{ nifi_content_archive_max_retention_period }}
nifi.content.repository.archive.max.usage.percentage={{ nifi_content_archive_max_usage_percentage }}
nifi.content.repository.archive.enabled={{ nifi_content_archive_enabled | lower }}
nifi.content.repository.always.sync={{ nifi_content_always_sync | lower }}
nifi.content.viewer.url=../nifi-content-viewer/

# Provenance Repository Properties
nifi.provenance.repository.implementation=org.apache.nifi.provenance.{{ nifi_provenance_implementation }}

# Persistent Provenance Repository Properties
{% for repo in nifi_provenance_repositories -%}
nifi.provenance.repository.directory.repo{{ loop.index0 }}={{ repo }}
{% endfor -%}
nifi.provenance.repository.max.storage.time={{ nifi_provenance_max_storage_time }}
nifi.provenance.repository.max.storage.size={{ nifi_provenance_max_storage_size }}
nifi.provenance.repository.rollover.time={{ nifi_provenance_rollover_time }}
nifi.provenance.repository.rollover.size={{ nifi_provenance_rollover_size }}
nifi.provenance.repository.query.threads={{ nifi_provenance_query_threads }}
nifi.provenance.repository.index.threads={{ nifi_provenance_index_threads }}
nifi.provenance.repository.compress.on.rollover=true
nifi.provenance.repository.always.sync=false
# Comma-separated list of fields. Fields that are not indexed will not be searchable. Valid fields are:
# EventType, FlowFileUUID, Filename, TransitURI, ProcessorID, AlternateIdentifierURI, Relationship, Details
nifi.provenance.repository.indexed.fields={{ nifi_provenance_indexed_fields }}
# FlowFile Attributes that should be indexed and made searchable.  Some examples to consider are filename, uuid, mime.type
nifi.provenance.repository.indexed.attributes=
# Large values for the shard size will result in more Java heap usage when searching the Provenance Repository
# but should provide better performance
nifi.provenance.repository.index.shard.size=500 MB
# Indicates the maximum length that a FlowFile attribute can be when retrieving a Provenance Event from
# the repository. If the length of any attribute exceeds this value, it will be truncated when the event is retrieved.
nifi.provenance.repository.max.attribute.length=65536
nifi.provenance.repository.concurrent.merge.threads=2


# Volatile Provenance Respository Properties
nifi.provenance.repository.buffer.size={{ nifi_provenance_repository_buffer_size }}

# Component and Node Status History Repository
nifi.components.status.repository.implementation=org.apache.nifi.controller.status.history.VolatileComponentStatusRepository

# Volatile Status History Repository Properties
nifi.components.status.repository.buffer.size={{ nifi_components_status_repository_buffer_size }}
nifi.components.status.snapshot.frequency={{ nifi_components_status_snapshot_frequency }}

# QuestDB Status History Repository Properties
nifi.status.repository.questdb.persist.node.days=14
nifi.status.repository.questdb.persist.component.days=3
nifi.status.repository.questdb.persist.location=./status_repository

# Site to Site properties
# nifi.remote.input.host={{ nifi_remote_input_host }}
# nifi.remote.input.secure={{ nifi_remote_input_secure | lower }}
# nifi.remote.input.socket.port={{ nifi_remote_input_socket_port }}
# nifi.remote.input.http.enabled={{ nifi_remote_input_http_enabled | lower }}
# nifi.remote.input.http.transaction.ttl=30 sec
# nifi.remote.contents.cache.expiration=30 secs

# web properties #
#############################################
{% if nifi_is_secure -%}

# For security, NiFi will present the UI on 127.0.0.1 and only be accessible through this loopback interface.
# Be aware that changing these properties may affect how your instance can be accessed without any restriction.
# We recommend configuring HTTPS instead. The administrators guide provides instructions on how to do this.

nifi.web.http.host=
nifi.web.http.port=
nifi.web.http.network.interface.default=
nifi.web.https.host={{ nifi_input_socket_host }}
nifi.web.https.port={{ nifi_web_https_port }}
nifi.web.https.network.interface.default=
{% else -%}
nifi.web.http.host={{ nifi_input_socket_host }}
nifi.web.http.port={{ nifi_web_http_port }}
nifi.web.http.network.interface.default=
nifi.web.https.host=
nifi.web.https.port=
nifi.web.https.network.interface.default=
{% endif -%}

#############################################

nifi.web.jetty.working.directory=./work/jetty
nifi.web.jetty.threads=200
nifi.web.max.header.size={{ nifi_web_max_header_size }}
nifi.web.proxy.context.path={{ nifi_web_proxy_context_path }}
nifi.web.proxy.host={{ nifi_web_proxy_host }}
nifi.web.max.content.size=
nifi.web.max.requests.per.second=30000
nifi.web.max.access.token.requests.per.second=25
nifi.web.request.timeout=60 secs
nifi.web.request.ip.whitelist=
nifi.web.should.send.server.version=true
nifi.web.request.log.format=%{client}a - %u %t "%r" %s %O "%{Referer}i" "%{User-Agent}i"

# Include or Exclude TLS Cipher Suites for HTTPS
nifi.web.https.ciphersuites.include=
nifi.web.https.ciphersuites.exclude=

# security properties #
nifi.sensitive.props.key={{ nifi_security_props_key | default('nififtw!') }}
nifi.sensitive.props.key.protected=
nifi.sensitive.props.algorithm={{ nifi_security_props_algorithm | default('NIFI_PBKDF2_AES_GCM_256') }}
nifi.sensitive.props.additional.keys=

nifi.security.autoreload.enabled=false
nifi.security.autoreload.interval=10 secs
{% if nifi_is_secure -%}
nifi.security.keystore={{ nifi_security_keystore }}
nifi.security.keystoreType={{ nifi_security_keystoreType }}
nifi.security.keystorePasswd={{ nifi_security_keystorePasswd }}
nifi.security.keyPasswd={{ nifi_security_keyPasswd }}
nifi.security.truststore={{ nifi_security_truststore }}
nifi.security.truststoreType={{ nifi_security_truststoreType }}
nifi.security.truststorePasswd={{ nifi_security_truststorePasswd }}
{% else -%}
nifi.security.keystore=
nifi.security.keystoreType=
nifi.security.keystorePasswd=
nifi.security.keyPasswd=
nifi.security.truststore=
nifi.security.truststoreType=
nifi.security.truststorePasswd=
{% endif -%}
nifi.security.needClientAuth={{ nifi_need_client_auth | default('')}}

nifi.security.user.authorizer={{ nifi_security_user_authorizer }}
nifi.security.allow.anonymous.authentication={{ nifi_security_allow_anonymous_authentication | lower }}
nifi.security.user.login.identity.provider={{ nifi_security_user_login_identity_provider }}
nifi.security.user.jws.key.rotation.period=PT1H
nifi.security.ocsp.responder.url=
nifi.security.ocsp.responder.certificate=

# OpenId Connect SSO Properties #
nifi.security.user.oidc.discovery.url=
nifi.security.user.oidc.connect.timeout=5 secs
nifi.security.user.oidc.read.timeout=5 secs
nifi.security.user.oidc.client.id=
nifi.security.user.oidc.client.secret=
nifi.security.user.oidc.preferred.jwsalgorithm=
nifi.security.user.oidc.additional.scopes=
nifi.security.user.oidc.claim.identifying.user=
nifi.security.user.oidc.fallback.claims.identifying.user=
nifi.security.user.oidc.truststore.strategy=JDK

# Apache Knox SSO Properties #
nifi.security.user.knox.url=
nifi.security.user.knox.publicKey=
nifi.security.user.knox.cookieName=hadoop-jwt
nifi.security.user.knox.audiences=

# SAML Properties #
nifi.security.user.saml.idp.metadata.url={{ nifi_security_user_saml_idp_metadata_url }}
nifi.security.user.saml.sp.entity.id={{ nifi_security_user_saml_sp_entity_id }}
nifi.security.user.saml.identity.attribute.name=
nifi.security.user.saml.group.attribute.name={{ nifi_security_user_saml_group_attribute_name }}
nifi.security.user.saml.metadata.signing.enabled=false
nifi.security.user.saml.request.signing.enabled=false
nifi.security.user.saml.want.assertions.signed=true
nifi.security.user.saml.signature.algorithm=http://www.w3.org/2001/04/xmldsig-more#rsa-sha256
nifi.security.user.saml.signature.digest.algorithm=http://www.w3.org/2001/04/xmlenc#sha256
nifi.security.user.saml.message.logging.enabled=false
nifi.security.user.saml.authentication.expiration=12 hours
nifi.security.user.saml.single.logout.enabled={{ nifi_security_user_saml_single_logout_enabled }}
nifi.security.user.saml.http.client.truststore.strategy=JDK
nifi.security.user.saml.http.client.connect.timeout=30 secs
nifi.security.user.saml.http.client.read.timeout=30 secs

# Identity Mapping Properties #
# These properties allow normalizing user identities such that identities coming from different identity providers
# (certificates, LDAP, Kerberos) can be treated the same internally in NiFi. The following example demonstrates normalizing
# DNs from certificates and principals from Kerberos into a common identity string:
#
{% if nifi_security_identity -%}
nifi.security.identity.mapping.pattern.dn=^CN=(.*?), OU=(.*?)$
nifi.security.identity.mapping.value.dn=$1
nifi.security.identity.mapping.transform.dn=LOWER
{% endif -%}

# nifi.security.identity.mapping.pattern.dn=^.*CN=(.*?)((,.*$)|($))
# nifi.security.identity.mapping.value.dn=$1
# nifi.security.identity.mapping.transform.dn=LOWER

# nifi.security.identity.mapping.pattern.kerb=^(.*?)/instance@(.*?)$
# nifi.security.identity.mapping.value.kerb=$1@$2
# nifi.security.identity.mapping.transform.kerb=UPPER

{% if nifi_security_user_login_identity_provider == "ldap-provider" %}

{% if nifi_ldap.ldap_username_in_lower_case %}
# LDAP username in lowercase
nifi.security.identity.mapping.pattern.dn=^(.*)$
nifi.security.identity.mapping.value.dn=$1
nifi.security.identity.mapping.transform.dn=LOWER
{% endif %}

{% if nifi_ldap.ldap_group_in_lower_case %}
# LDAP group in lowercase 
nifi.security.group.mapping.pattern.anygroup=^(.*)$
nifi.security.group.mapping.value.anygroup=$1
nifi.security.group.mapping.transform.anygroup=LOWER
{% endif %}

{% endif %}

# Group Mapping Properties #
# These properties allow normalizing group names coming from external sources like LDAP. The following example
# lowercases any group name.
#
# nifi.security.group.mapping.pattern.anygroup=^(.*)$
# nifi.security.group.mapping.value.anygroup=$1
# nifi.security.group.mapping.transform.anygroup=LOWER

# Listener Bootstrap properties #
# This property defines the port used to listen for communications from NiFi Bootstrap. If this property
# is missing, empty, or 0, a random ephemeral port is used.
nifi.listener.bootstrap.port={{ nifi_bootstrap_listen_port }}

# cluster common properties (all nodes must have same values) #
nifi.cluster.protocol.heartbeat.interval={{ nifi_cluster_protocol_heartbeat_interval }}
nifi.cluster.protocol.heartbeat.missable.max=8
nifi.cluster.protocol.is.secure={{ nifi_is_secure | lower }}

# cluster node properties (only configure for cluster nodes) #
nifi.cluster.is.node={{ (not nifi_single_node) | lower }}
nifi.cluster.node.address={{ nifi_cluster_node_address }}
nifi.cluster.node.protocol.port={{ nifi_cluster_node_protocol_port }}
nifi.cluster.node.protocol.max.threads=50
nifi.cluster.node.event.history.size=25
nifi.cluster.node.connection.timeout={{ nifi_cluster_node_connection_timeout }}
nifi.cluster.node.read.timeout={{ nifi_cluster_node_read_timeout }}
nifi.cluster.node.max.concurrent.requests=100
nifi.cluster.node.load.balance.port=6342
nifi.cluster.firewall.file=
nifi.cluster.flow.election.max.wait.time=5 mins
{% if nifi_zookeeper_servers | length > 0 -%}
nifi.cluster.flow.election.max.candidates={{ nifi_zookeeper_servers | length }}
{% else -%}
nifi.cluster.flow.election.max.candidates=
{% endif -%}

# cluster load balancing properties #
nifi.cluster.load.balance.host=
nifi.cluster.load.balance.port=6342
nifi.cluster.load.balance.connections.per.node=2
nifi.cluster.load.balance.max.thread.count=8
nifi.cluster.load.balance.comms.timeout=30 sec

# zookeeper properties, used for cluster management #
{% if nifi_zookeeper_servers | length > 0 -%}
nifi.zookeeper.connect.string={{ nifi_zookeeper_servers | join(':2181,') }}:2181
{% else -%}
nifi.zookeeper.connect.string=
{% endif -%}
nifi.zookeeper.connect.timeout={{ nifi_zookeeper_connect_timeout }}
nifi.zookeeper.session.timeout={{ nifi_zookeeper_session_timeout }}
nifi.zookeeper.root.node={{ nifi_zookeeper_root_node }}
nifi.zookeeper.client.secure=false
nifi.zookeeper.security.keystore=
nifi.zookeeper.security.keystoreType=
nifi.zookeeper.security.keystorePasswd=
nifi.zookeeper.security.truststore=
nifi.zookeeper.security.truststoreType=
nifi.zookeeper.security.truststorePasswd=
nifi.zookeeper.jute.maxbuffer=

# Zookeeper properties for the authentication scheme used when creating acls on znodes used for cluster management
# Values supported for nifi.zookeeper.auth.type are "default", which will apply world/anyone rights on znodes
# and "sasl" which will give rights to the sasl/kerberos identity used to authenticate the nifi node
# The identity is determined using the value in nifi.kerberos.service.principal and the removeHostFromPrincipal
# and removeRealmFromPrincipal values (which should align with the kerberos.removeHostFromPrincipal and kerberos.removeRealmFromPrincipal
# values configured on the zookeeper server).
nifi.zookeeper.auth.type=
nifi.zookeeper.kerberos.removeHostFromPrincipal=
nifi.zookeeper.kerberos.removeRealmFromPrincipal=

# kerberos #
nifi.kerberos.krb5.file={{ nifi_kerberos_krb5_file }}

# kerberos service principal #
nifi.kerberos.service.principal=
nifi.kerberos.service.keytab.location=

# kerberos spnego principal #
nifi.kerberos.spnego.principal=
nifi.kerberos.spnego.keytab.location=
nifi.kerberos.spnego.authentication.expiration=12 hours

# external properties files for variable registry
# supports a comma delimited list of file locations
nifi.variable.registry.properties={{ nifi_variable_registry_properties | join(',') }}

# analytics properties #
nifi.analytics.predict.enabled=false
nifi.analytics.predict.interval=3 mins
nifi.analytics.query.interval=5 mins
nifi.analytics.connection.model.implementation=org.apache.nifi.controller.status.analytics.models.OrdinaryLeastSquares
nifi.analytics.connection.model.score.name=rSquared
nifi.analytics.connection.model.score.threshold=.90

# runtime monitoring properties
nifi.monitor.long.running.task.schedule=
nifi.monitor.long.running.task.threshold=

# Create automatic diagnostics when stopping/restarting NiFi.

# Enable automatic diagnostic at shutdown.
nifi.diagnostics.on.shutdown.enabled=false

# Include verbose diagnostic information.
nifi.diagnostics.on.shutdown.verbose=false

# The location of the diagnostics folder.
nifi.diagnostics.on.shutdown.directory=./diagnostics

# The maximum number of files permitted in the directory. If the limit is exceeded, the oldest files are deleted.
nifi.diagnostics.on.shutdown.max.filecount=10

# The diagnostics folder's maximum permitted size in bytes. If the limit is exceeded, the oldest files are deleted.
nifi.diagnostics.on.shutdown.max.directory.size=10 MB

# NAR Provider Properties #
# These properties allow configuring one or more NAR providers. A NAR provider retrieves NARs from an external source
# and copies them to the directory specified by nifi.nar.library.autoload.directory.
#
# Each NAR provider property follows the format:
#  nifi.nar.library.provider.<identifier>.<property-name>
#
# Each NAR provider must have at least one property named "implementation".
#
# Example HDFS NAR Provider:
#   nifi.nar.library.provider.hdfs.implementation=org.apache.nifi.nar.hadoop.HDFSNarProvider
#   nifi.nar.library.provider.hdfs.resources=/path/to/core-site.xml,/path/to/hdfs-site.xml
#   nifi.nar.library.provider.hdfs.storage.location=hdfs://hdfs-location
#   nifi.nar.library.provider.hdfs.source.directory=/nars
#   nifi.nar.library.provider.hdfs.kerberos.principal=nifi@NIFI.COM
#   nifi.nar.library.provider.hdfs.kerberos.keytab=/path/to/nifi.keytab
#   nifi.nar.library.provider.hdfs.kerberos.password=
#
# Example NiFi Registry NAR Provider:
#   nifi.nar.library.provider.nifi-registry.implementation=org.apache.nifi.registry.extension.NiFiRegistryNarProvider
#   nifi.nar.library.provider.nifi-registry.url=http://localhost:18080
